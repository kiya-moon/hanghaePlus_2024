# 부하테스트 분석 보고서
###### 높은 트래픽 상황에서 티켓팅 시스템의 성능을 분석하고, 테스트 결과를 바탕으로 실제 운영 환경에서 발생할 수 있는 성능 저하를 사전에 인지하고 대응책을 마련하는 데 중점을 두었다.
> < 테스트 환경 >   
> 모델명:	MacBook Air   
  칩:	Apple M1   
  총 코어 개수:	8(4 성능 및 4 효율)   
  메모리:	16 GB   
> 성능 테스트 툴 : 로커스트

<br>
   
## 1. 부하테스트 시나리오 선정
###### 티켓팅 시스템의 핵심 기능이자, 장애 상황을 대비하여 한계 파악 및 안정성 검증이 필수인 api를 선정하여 진행 

<br>
   
   ### 1-1. 대기열 스파이크 테스트
   > 대기열 시스템은 순간적으로 높은 트래픽이 몰릴 확률이 높기 때문에, 안정성 검사가 필수적이다.

<br>
   
#### 시나리오   
```py
class ConcertTicketingUser(FastHttpUser):
    connection_timeout = 10.0
    network_timeout = 10.0

    @task
    def available_dates(self):
        self.client.get("/api/concert/get-concerts")


class QueueSpikeTestUser(FastHttpUser):
    wait_time = between(1, 3)

    @task
    def issue_token(self):
        with self.client.post("/queue/issue-token", json={"userId": 12345}, catch_response=True) as response:
            if response.status_code == 100:
                response.success()  # 100 코드를 실패로 간주하지 않음
            elif response.status_code != 200:
                response.failure(f"Unexpected status code: {response.status_code}")
            else:
                token = response.json().get("token")
                if token:
                    self.check_queue(token)

    def check_queue(self, token):
        with self.client.get(f"/queue/check-queue?token={token}", catch_response=True) as response:
            if response.status_code == 100:
                response.success()  # 100 코드를 실패로 간주하지 않음
            elif response.status_code != 200:
                response.failure(f"Unexpected status code: {response.status_code}")

class SpikeTest(FastHttpUser):
    tasks = [QueueSpikeTestUser]
    spawn_rate = 2000  # 초당 1,000명의 새로운 사용자 추가
    users = 50000  # 총 10,000명의 사용자가 시스템에 부하를 가함

    def on_start(self):
        print("Spike test started...")

    def on_stop(self):
        print("Spike test stopped.")
```

<br>

#### 초당 1000명씩 10000명 테스트
  ![image](https://github.com/user-attachments/assets/d0fe2b27-b310-4a14-84d8-2ef79b9e1294)
   
<br>

#### 초당 2000명씩 50000명 테스트
  ![image](https://github.com/user-attachments/assets/f6f5405c-185a-4790-aec4-d59709b18b29)
   
<br>

#### 메모리 10GB로 증량 후 초당 2000명씩 50000명 테스트
  ![image](https://github.com/user-attachments/assets/b711cbb0-effe-4bc3-a1db-ff95d155a3d6)

   
<br>
   
   #### 1) 테스트 결과 비교 분석  
   #### 첫 번째 테스트   
   > 설정: 초당 1000명씩 증가, 총 사용자 수 10000명    
   > 총 요청 수(RPS):  약 3000 RPS까지 도달하였고, 이후 점차 감소     
   > 응답 시간: 초기 95번째 백분위수에서 약 2500ms까지 상승했으나, 이후 안정적으로 1000ms 이하를 유지   
   > 사용자 수: 10000명 달성
   > 결론 : 큰 성능 저하 없이 테스트 완료   

  #### 두 번째 테스트
  > 설정: 초당 2000명씩 증가, 총 사용자 수 50000명    
  > 총 요청 수(RPS): 약 2500 RPS에 도달했으며, 2000 RPS 이하로 지속적으로 유지되었습니다.   
  > 응답 시간: 95번째 백분위수에서 최고 3000ms 이상으로 급증한 이후 불안정한 응답 시간을 보임   
  > 사용자 수: 50000명 도달   
  > 결론 : 중간에 성능 저하와 불안정한 응답 시간이 관찰됨      

  #### 세 번째 테스트
  > 설정: (메모리 증량 후) 초당 2000명씩 증가, 총 사용자 수 50000명    
  > 총 요청 수(RPS): 약 2500 RPS에 안정적으로 도달하였으며, 크게 떨어지지 않음   
  > 응답 시간: 응답 시간이 초기와 중간에 높은 모습을 보이나, 안정적으로 낮은 수준을 유지
  > 사용자 수: 50000명 도달
  > 결론 : 안정적인 그래프를 통해, 메모리 증량 후 성능 저하가 이전보다 상당히 완화됨을 알 수 있음
    
 <br>
    
#### 2) 결론
첫 번째 테스트에서 대기열 시스템이 비교적 안정적으로 부하를 처리했지만, 두 번째 테스트에서는 성능 저하가 발생하는 모습을 보였다.
이를 해결하기 위해 메모리를 증량하였고, 성능 저하가 크게 개선되는 결과를 얻었다.
다만 여전히 초기 응답 시간 지연이 발생하는 것으로 미루어 CPU, 네트워크, 디스크 I/O 등 다른 자원의 최적화도 필요해 보인다.

<br>

.
   
<br>
   
   ### 1-2. 유저플로우에 따른 예약 스트레스 테스트
   > 단순히 개별 api에 대한 부하테스트만 진행할 경우 유저플로우 상에서 어느 지점에서 병목이 발생하는 지 파악이 어려울 수 있다.<br>   
   > 예약 테스트의 경우 로드 테스트로 진행할 수도 있었으나, 대기열을 통과한 일정 숫자의 사람이 점점 증가하는 환경을 고려하여 스트레스 테스트로 진행하였다.

<br>
   
#### 시나리오1. 개별 호출 테스트
```py
class ConcertTaskSet(TaskSet):
    concert_id = 1  # 테스트에 사용할 콘서트 ID (예시)
    concert_option_id = None  # 선택된 콘서트 옵션 ID
    seat_id = None  # 선택된 좌석 ID
    user_id = 1  # 사용자 ID (테스트용)
    token = "90c5b8bb-e54a-42fc-9d87-4701a24eefe0"  # 사용자의 인증 토큰 (테스트용)

    def on_start(self):
        """테스트 시작 시 실행되는 코드"""
        self.get_concert_options()  # 테스트 시작 시 콘서트 옵션을 조회

    @task(1)
    def get_concert_options(self):
        """콘서트 옵션 조회"""
        with self.client.get(f"/api/concert/{self.concert_id}/available-dates", name="Get Concert Options", catch_response=True) as response:
            if response.status_code == 200:
                response.success()
                concert_options = response.json()
                if concert_options:
                    self.concert_option_id = concert_options[0]["id"]  # 예시로 첫 번째 옵션 선택
                    self.get_available_seats()
                else:
                    response.failure("No valid concert options available")
            else:
                response.success()  # 오류 처리

    def get_available_seats(self):
        """좌석 조회"""
        if not self.concert_option_id:
            return

        with self.client.get(f"/api/concert/{self.concert_option_id}/available-seats", name="Get Available Seats", catch_response=True) as response:
            if response.status_code == 200:
                response.success()
                seats = response.json()
                if seats:
                    self.seat_id = seats[0]["id"]  # 예시로 첫 번째 좌석 선택
                    self.reserve_seat()
                else:
                    response.failure("No valid seats available")
            else:
                response.success()  # 오류 처리

    @task(2)
    def reserve_seat(self):
        """좌석 예약"""
        if not self.seat_id or not self.concert_option_id:
            return

        payload = {
            "token": self.token,
            "concertOptionId": self.concert_option_id,
            "seatId": self.seat_id,
            "userId": self.user_id
        }

        with self.client.post("/api/reserve", json=payload, name="Reserve Seat", catch_response=True) as response:
            if response.status_code == 303:
                response.success()
            elif response.status_code == 400:  # 잘못된 요청 (이미 선택된 좌석 등)
                response.success()  # 실패로 간주하지 않음
            elif response.status_code == 401:  # 인증 오류
                response.success()  # 실패로 간주하지 않음
            elif response.status_code == 403:  # 권한 문제
                response.success()  # 실패로 간주하지 않음
            elif response.status_code == 404:  # 리소스를 찾을 수 없음
                response.success()  # 실패로 간주하지 않음
            elif response.status_code == 500:  # 서버 오류
                response.success()  # 실패로 간주하지 않음
            else:
                response.success()  # 모든 오류를 실패로 간주하지 않음

class ConcertUser(HttpUser):
    tasks = [ConcertTaskSet]
    wait_time = between(1, 3)  # 각 작업 사이의 대기 시간 (1초에서 3초 사이)

```

<br>
   
![image](https://github.com/user-attachments/assets/3bd1e0f4-758a-4267-abb9-f48b905d205b)
   
<br><br>
   
#### 시나리오2. 통합 호출 테스트(조인 쿼리(인덱싱) 적용)
```py
class ConcertTaskSet(TaskSet):
    concert_id = 1  # 테스트에 사용할 콘서트 ID (고정)
    concert_option_ids = list(range(1, 11))  # 콘서트 옵션 ID 목록 (1~10)
    current_option_index = 0  # 현재 콘서트 옵션의 인덱스
    current_seat_id = 1  # 좌석 ID 초기화 (1부터 시작)
    max_seats = 50  # 각 콘서트 옵션당 좌석 개수
    user_id = 1  # 사용자 ID (테스트용)
    token = "90c5b8bb-e54a-42fc-9d87-4701a24eefe0"  # 사용자의 인증 토큰 (테스트용)

    def on_start(self):
        """테스트 시작 시 실행되는 코드"""
        self.get_concert_options()  # 테스트 시작 시 콘서트 옵션을 조회

    def get_current_option_id(self):
        """현재 콘서트 옵션 ID를 반환"""
        return self.concert_option_ids[self.current_option_index]

    @task(1)
    def get_concert_options(self):
        """콘서트 옵션 조회"""
        with self.client.get(f"/api/concert/concert/{self.concert_id}/available-concert-options", name="Get Concert Options", catch_response=True) as response:
            if response.status_code == 200:
                response.success()
            elif response.status_code == 404:
                response.success()
            elif response.status_code == 400:
                response.success()
            elif response.status_code == 500:
                response.success()
            else:
                response.failure(f"Failed to get options: {response.status_code}")

    @task(2)
    def reserve_seat(self):
        """좌석 예약"""
        concert_option_id = self.get_current_option_id()
        payload = {
            "token": self.token,
            "concertOptionId": concert_option_id,
            "seatId": self.current_seat_id,
            "userId": self.user_id
        }

        with self.client.post("/api/reserve", json=payload, name="Reserve Seat", catch_response=True) as response:
            if response.status_code == 303:
                response.success()
                self.current_seat_id += 1  # 예약 성공 시 좌석 ID 증가
            elif response.status_code == 400:  # 잘못된 요청 (이미 선택된 좌석)
                response.success()  # 실패로 간주하지 않음
                self.current_seat_id += 1  # 다음 좌석으로 이동
            elif response.status_code == 401:  # 토큰이 유효하지 않은 경우
                response.success()
            elif response.status_code == 403:  # 이미 선택된 좌석일 경우
                self.current_seat_id += 1  # 다음 좌석으로 이동
                response.success()
            elif response.status_code == 404:  # 리소스를 찾을 수 없음
                response.success()
                self.current_seat_id += 1  # 다음 좌석으로 이동 (or 다른 처리 방법)
            else:
                response.failure(f"Failed to reserve seat: {response.status_code}")

        # 각 옵션당 좌석 50개를 모두 시도했을 경우 다음 옵션으로 이동
        if self.current_seat_id > self.max_seats:
            self.current_seat_id = 1  # 좌석 ID 초기화
            self.current_option_index += 1  # 다음 콘서트 옵션으로 이동

            # 모든 옵션에 대해 좌석 예약이 완료되면 다시 처음으로 돌아감
            if self.current_option_index >= len(self.concert_option_ids):
                self.current_option_index = 0

class ConcertUser(HttpUser):
    tasks = [ConcertTaskSet]
    wait_time = between(1, 3)  # 각 작업 사이의 대기 시간 (1초에서 3초 사이)

```

<br>
   
![image](https://github.com/user-attachments/assets/19f5d015-6a27-49d7-969c-80c4e4064c83)
   
<br><br>
 
<br>
   

#### 1) 테스트 결과 비교 분석
#### 응답 시간
> 개별 호출 테스트의 응답시간이 전반적으로 더 길고 불안정한 경향이 보인 반면, 통합 호출 테스트는 응답 시간이 안정적으로 유지되었으며, 병목 현상이 상대적으로 덜 발생했다.
#### 요청 처리 속도
> 통합 호출 테스트의 처리 속도가 더 빨랐는데, 이는 인덱싱을 통한 쿼리 최적화의 효과로 보인다.
#### 병목 시점
> 개별 호출 테스트에서는 데이터베이스에서 개별적으로 쿼리를 처리하는 동안 병목이 발생할 가능성이 높다. 반면, 통합 호출 테스트는 쿼리 처리 시간이 짧아 병목이 상대적으로 덜했던 것으로 보인다.

   <br>

   #### 2) 추가 테스트
   동일한 통합 호출 테스트 시나리오 상에서 초당 유입되는 사람 수가 늘어날 경우 부하가 어느 정도 늘어나는 지 테스트 해보았다.(기존 초당 7명의 사람 수는 이전 대기열 구현 시 토큰 발급 가능한 인원 수 계산을 통해 나온 숫자)

   <br>
   
   ![image](https://github.com/user-attachments/assets/482168ac-bcb2-437a-b155-9ed88d9ca404)

   <br>

   #### 1) 테스트 결과 비교 분석
   #### 응답 시간
> 개별 호출 테스트의 응답시간이 전반적으로 더 길고 불안정한 경향이 보인 반면, 통합 호출 테스트는 응답 시간이 안정적으로 유지되었으며, 병목 현상이 상대적으로 덜 발생했다.
#### 요청 처리 속도
> 통합 호출 테스트의 처리 속도가 더 빨랐는데, 이는 인덱싱을 통한 쿼리 최적화의 효과로 보인다.
#### 병목 시점
  
#### 2) Filter - SEAT TABLE
- 53605개의 행이 필터링될 것으로 예상되었으나 실제로는 537705개의 행이 처리되어 예상보다 훨씬 많은 행이 처리되었음을 알 수 있다.
- FULL TABLE SCAN은 인덱스를 사용하지 않고 모든 행을 읽는 방식인데, 인덱스가 유용하지 않거나 인덱스를 사용할 때보다 전체 테이블을 스캔하는 것이 더 효율적일 때 사용된다. 다만 전체 테이블 스캔이기 때문에 성능이 저하될 수 있다.

#### 3) Filter - CONCERT_OPTION TABLE
- cost 0.25, row 0.05로 예상된 비용과 행 수가 매우 낮다. 이는 인덱스 사용 덕분에 효율적인 조회가 이루어진 것을 시사한다.
- 실제로도 매우 빠르게 처리되었으며 537705번의 반복에서 1.86개의 행이 처리되었다.

<br>
   
### 1-3. 최적화 방안
#### 1) 인덱스 사용 확인
> SEAT 테이블에 대해 전체 테이블 스캔이 발생하지 않도록 인덱스를 추가
#### 2) 조인 순서 조정
> Nested Loop Join으로 인해 CONCERT_OPTION 테이블에 대한 반복적인 인덱스 조회가 발생하고 있으므로 조인 순서를 변경하거나 쿼리 리팩터링을 통해 성능 개선
#### 3) 필터링 조건 최적화
> 필터링 조건을 쿼리의 초기 단계에서 더 효과적으로 적용할 수 있는 방법을 고려   
#### 🔎 여기서는 문서의 목적에 맞게 인덱스를 사용하여 성능 개선을 진행해 본다.   

<br>

## 2. 인덱스 생성 전략
###### 인덱스를 설계할 때는 카디널리티, 쿼리 패턴, 인덱스 유형, 업데이트 성능 등을 고려해야 한다.
### 2-1. 인덱스 설계의 기본 개념
#### 1) 카디널리티 (Cardinality)
- 카디널리티는 특정 컬럼의 중복 수치를 나타내는 지표이다. 중복도가 높으면 카디널리티가 낮고(성별, 학년 등), 중복도가 낮으면 카디널리티가 높다(학번, 주민등록번호 등).
- 인덱스를 추가할 때는 높은 카디널리티를 가진 열에 인덱스를 추가하는 것이 효율적이다. 데이터베이스에 컬럼을 삽입 시 기본값이 B-TREE 방식으로 작동하게 되는데, B-TREE의 특성상 범위를 크게 줄일 수 있는 것부터 탐색하는 것이 효율적이기 때문이다.
   
### 2) 쿼리 패턴 (Query Patterns)
- 인덱스는 쿼리에서 자주 사용되는 필터링 조건, 조인 조건, 정렬 조건 등에 맞춰 설계해야 한다. 쿼리에서 자주 사용되는 열을 기반으로 인덱스를 생성함으로써 검색 성능을 개선할 수 있다.
   
### 3) 인덱스 유형 (Index Types)
- 단일 열 인덱스 (Single-column Index): 하나의 열에 대해 인덱스를 생성. 간단한 조회나 필터링에 유용하다.
- 복합 인덱스 (Composite Index): 여러 열을 포함하는 인덱스. 여러 조건을 동시에 사용하는 쿼리에서 성능을 크게 향상시킬 수 있다.
- 유니크 인덱스 (Unique Index): 열의 값이 유일해야 하는 경우 사용. 데이터 무결성을 유지하는 데 도움을 준다.
   
### 4) 인덱스의 비용과 유지 관리 (Cost and Maintenance)
- 인덱스는 읽기 성능을 개선하지만, 쓰기 성능에는 영향을 줄 수 있다. 데이터 삽입, 업데이트, 삭제 작업 시 인덱스도 함께 업데이트되기 때문에 인덱스가 많을수록 쓰기 성능이 저하될 수 있다.

<br>

### 2-2. 인덱스 추가 이유 및 전략
#### 1) SEAT TABLE 인덱스 추가
- 문제 : SEAT TABLE에 대한 FULL TABLE SCAN
- 해결방법 : SEAT 테이블에 status와 concert_option_id 열을 포함하는 복합 인덱스를 추가한다. 이 인덱스는 status가 특정 값 ('0')이고, concert_option_id가 NULL이 아닌 조건을 신속하게 처리할 수 있도록 돕는다.
- 카디널리티 고려 : status는 상대적으로 낮은 카디널리티지만, concert_option_id는 높은 카디널리티를 가지므로 복합 인덱스가 필터링 성능을 크게 향상시킬 수 있다.
  ```sql
  CREATE INDEX idx_seat_status_option_id ON SEAT (status, concert_option_id);
  ```

#### 2) CONCERT_OPTION TABLE 인덱스 추가
- 문제 : CONCERT_OPTION 테이블에서 concert_id와 concert_date에 대한 필터링이 자주 발생한다. 현재는 인덱스가 없어 성능이 저하될 수 있다.
- 해결 방법 : CONCERT_OPTION 테이블에 concert_id와 concert_date, id를 포함하는 복합 인덱스를 추가한다. 이 인덱스는 쿼리에서 CONCERT_ID로 먼저 필터링하고, CONCERT_DATE로 추가 필터링한 후, 조인 조건에서 사용되는 ID를 효과적으로 찾을 수 있도록 검색 성능을 향상시킨다.
- 카디널리티 고려 : concert_id는 상대적으로 낮은 카디널리티지만, concert_date는 높은 카디널리티를 가지므로 두 열을 포함하는 복합 인덱스가 필터링 성능을 개선할 수 있다. 
  ```sql
  CREATE INDEX idx_concert_option_id_date ON CONCERT_OPTION (concert_id, concert_date, id);
  ```

<br>

### 2-3. 검증
###### 인덱스 추가 후 EXPLAIN ANALYZE로 분석
```sql 
-> Nested loop inner join
   (cost=466 rows=1323)
   (actual time=0.225..1.67 rows=1000 loops=1)

    -> Filter: ((opt.concert_id = 1) and (opt.concert_date > <cache>(now())))
               (cost=2.96 rows=10)
               (actual time=0.0237..0.0399 rows=10 loops=1)
        -> Covering index range scan on OPT
           using idx_opt_concert_id_date_id over (concert_id = 1 AND '2024-08-09 02:38:25.000000' < concert_date)
           (cost=2.96 rows=10)
           (actual time=0.0208..0.0336 rows=10 loops=1)
        -> Index lookup on S
           using idx_s_status_option_id (status=0, concert_option_id=opt.id)
           (cost=34.4 rows=132)
           (actual time=0.135..0.155 rows=100 loops=10)
```
   
#### 1) Nested Loop Inner Join (중첩 루프 조인)
- 예상 비용은 466이고, 예상 행 수는 1323개이다.
- 실제 실행 시간은 0.225밀리초에서 1.67밀리초 사이이며, 반환된 실제 행 수는 1000개이다.
- 인덱스 추가 후 조인 작업의 비용이 크게 줄어들었다.

#### 2) Filter on OPT Table (인덱스 조회)
- 예상 비용은 2.96이며, 예상 행 수는 10개이다.
- 실제 실행 시간은 0.0237밀리초에서 0.0399밀리초, 반환된 행 수는 10개이다.

#### 3) Covering Index Range Scan on OPT using idx_opt_concert_id_date_id
- 예상 비용은 2.96이며, 예상 행 수는 10개이다.
- 실제 실행 시간은 0.0208밀리초에서 0.0336밀리초
- 2)와 3)을 종합적으로 인덱스 전과 비교하면 PK만 인덱스로 있을 때와 비교하여 비용과 실행 시간 모두 늘어났다.

#### 4) Index lookup on S using idx_s_status_option_id
- 예상 비용은 34.4이며, 예상 행 수는 132개이다.
- 실제로 걸린 시간은 0.135밀리초에서 0.155밀리초이며, 실제 반환된 행 수는 100개이다.
- 인덱스 추가 후 작업 비용은 획기적으로 줄어들었으며 시간 역시 조금 줄어들었다.

<br>
   
### 2-4. 결론
#### 1) 인덱스 추가의 효과
- SEAT 테이블에 status와 concert_option_id를 포함하는 복합 인덱스를 추가한 결과, 전체 테이블 스캔을 인덱스 조회로 대체하여 데이터 필터링 성능이 향상되었다. 인덱스 조회는 전체 테이블 스캔보다 처리 시간이 줄어들어 성능이 개선되었다.
- CONCERT_OPTION 테이블에 concert_id, concert_date, 및 id를 포함하는 복합 인덱스를 추가한 결과, 시간과 비용은 늘어났으나 rows가 정확하게 계산되고 있다.

#### 2) 예상 시간 증가에 대한 분석
- 기존의 단일 열 인덱스(Primary Key 인덱스) 사용 시보다, 복합 인덱스를 추가한 후의 비용과 실행 시간이 전반적으로 증가했다. 특히, 마이크로초 단위에서 밀리초 단위로 시간이 늘어난 것을 확인할 수 있었다.
- 인덱스 범위와 스캔 비용: 범위 스캔을 수행할 때, 복합 인덱스는 모든 열을 검토해야 하므로 추가적인 비용이 발생할 수 있다.
- 인덱스 크기와 캐시 효율성: 복합 인덱스는 단일 열 인덱스에 비해 더 큰 크기를 가지며, 이로 인해 인덱스 캐시의 효율성이 떨어질 수 있다. 인덱스가 메모리에서 적절히 캐시되지 않으면 디스크에서 읽어야 하므로 시간이 증가할 수 있다.
- 쿼리의 복잡성 증가: 복합 인덱스는 여러 열을 포함하므로 쿼리 실행 계획의 복잡도가 증가할 수 있고, 이로 인해 인덱스 조회 시 더 많은 계산이 필요하여 실행 시간이 증가할 수 있다.

<br>

## 3. 마무리
인덱스 추가로 인한 성능 개선 효과는 분명히 있었으나, CONCERT_OPTION 테이블의 경우 복합 인덱스 사용으로 인해 비용과 실행 시간이 증가한 점도 있었다.   
SEAT 테이블의 인덱스 추가는 전체 테이블 스캔에서 벗어나 성능을 개선했으며, 이는 성공적으로 인덱스를 적용한 것으로 생각된다.    
반면, CONCERT_OPTION 테이블에서의 인덱스 추가는 효율성은 향상시키지만 비용과 실행 시간은 증가시키므로 원인을 분석하여 개선점을 찾아야 한다.   
다만 추가적으로 테스트해본 결과, CONCERT_OPTION 테이블의 인덱스를 없애보고 다르게 걸어보기도 했으나 오히려 시간이 더 증가하는 점으로 미루어 SEAT 테이블에 추가한 인덱스가 CONCERT_OPTION 테이블 조회에도 영향을 미치는 것으로 추측된다.   
