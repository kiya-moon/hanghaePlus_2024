## 개념
### 1. 캐싱 전략이란?
> 웹 서비스 환경에서 시스템 성능 향을 기대할 수 있는 중요한 기술   
   
일반적으로 캐시는 메모리를 사용하기 때문에 DB보다 빠른 응답이 가능하기 때문에 이용자에게 빠르게 서비스를 제공할 수 있다. 하지만 메모리에 저장할 수 있는 용량은 한정적이어서 어느 종류의 데이터를 저장하고, 어떻게 캐시를 관리할 지 전략이 필요하다.   
   
캐시에 저장하는 데이터는 자주 조회되지만 결과값이 빈번하게 변동되지 않고 일정한 데이터, 조회하는데 연산이 필요한 데이터가 좋다.   

<br>
   
## 적용해보기
### 1. WHERE?
> 내 프로젝트에서 캐싱할 데이터 : 콘서트 목록, 콘서트 옵션

내 프로젝트에서 사용자의 플로우는 다음과 같다.   
전체 콘서트 목록 조회 > 콘서트 선택(옵션 조회) > 대기열 진입 > (폴링) > 대기열 통과 > 콘서트 옵션 조회 > 콘서트 좌석 조회 > 예약 > 결제   
이 중에서 데이터가 많고 자주 조회되는 부분은 콘서트 목록, 콘서트 옵션, 콘서트 좌석이다.   
   
콘서트 목록 조회 > 콘서트 옵션 조회는 대개 한 번의 플로우로 진행될 것으로 예상된다. 반면에 좌석 조회는 예약 가능한 좌석을 찾기 위해 여러 번 조회가 이루어진다. 즉, DB에 부하가 걸리게 된다. 하지만 좌석은 빈번하게 데이터가 업데이트 되므로 캐시로 관리할 경우 캐시에 저장된 데이터와 DB의 데이터 사이의 정합성 문제가 발생된다. 또한 데이터가 빈번하게 변경되면 캐시를 갱신하는 데 드는 비용이 커져, 캐싱의 이점(성능 향상)이 줄어들게 되므로 콘서트 좌석은 캐싱할 데이터에서 제외한다.   
   
콘서트와 콘서트 옵션은 데이터 양이 많아 매번 조회 시엔 DB에 부하를 줄 수 있지만 한 번 데이터에 저장되면 수정이 필요하기 전까지는 계속 같은 데이터가 조회되므로 캐싱하기에 적합하다.    

<br>

### 2. HOW?
> Cache Aside 패턴 사용, CacheEvict를 사용해서 캐시 만료 처리

Cache Aside : 데이터를 찾을때 우선 캐시에 저장된 데이터가 있는지 우선적으로 확인하는 전략. 만일 캐시에 데이터가 없으면 DB에서 조회한다.   
   
레디스의 여러 캐시 패턴 중 많이 사용되는 패턴이고, 반복적인 읽기가 많은 호출에 적합하기 때문에 선택했다.  

CacheEvict : 캐시된 데이터가 더 이상 유효하지 않거나 갱신되어야 할 때, 해당 캐시를 비우고 새 데이터를 캐싱할 수 있도록 한다.   
   
Expiration를 통해 특정 시간 이후에 캐시된 데이터가 자동으로 무효화되거나 제거되게 할 수도 있지만, 만료 시간 전에 DB의 데이터가 변경 될 경우 정합성이 깨질 수도 있고, 만료시간을 잘못 설정함에 따라 예상치 못한 캐시 무효화나 메모리 낭비가 있을 수 있다.   
   
때문에 데이터 수정이 필요할 때, 예를 들어, 뮤지컬이었다면 캐스트 변경, 좌석 단체 예약으로 인한 예약 불가 공지 등, 필요 시 원하는 시점에 캐싱된 데이터를 제거하고 다시 올릴 수 있도록 CacheEvict를 사용했다.   
```java 
    // 콘서트 목록 조회
    @Cacheable(value = "concerts", cacheManager = "userCacheManager")
    public List <ConcertEntity> getConcerts() {
        List<ConcertEntity> concerts = concertRepository.findAll();
        if (concerts.isEmpty()) {
            throw new IllegalArgumentException("콘서트 목록이 존재하지 않습니다.");
        }
        return concerts;
    }

    // 콘서트 정보 저장
    @CacheEvict(value = "concerts", allEntries = true)
    public void saveConcert(ConcertEntity concertEntity) {
        concertRepository.save(concertEntity);
    }
```
 
<br>

### 3. RESULT?
> 캐싱 후 확연하게 줄어든 조회 시간!

캐싱 전 : 244ms
<img width="1440" alt="콘서트 조회" src="https://github.com/user-attachments/assets/da07cc56-7752-4768-a2d5-3d19c8b16ffb">

캐싱 후 : 27ms
<img width="1440" alt="캐싱 후 콘서트 조회" src="https://github.com/user-attachments/assets/9a35a43e-950e-46df-b5b7-7b0928df44bc">
   
실제로 캐싱 전후의 속도 차이를 확인하니 적절한 캐싱이 얼마나 중요한 지 알 수 있었다. 10분의 1가량 줄어든 시간만큼 분당 (아마) 초당 처리할 수 있는 TPS가 늘어나서 결국 분당 처리할 수 있는 사용자 수의 증가로 이어질 것이다.
   
<br>

## 아쉬운 점
프로메테우스와 그라파나를 사용해서 서버와 cpu + 레디스 메트릭 연결하고 부하테스트를 진행해서 캐싱 전후에 몇 건의 조회 요청까지 허용이 가능한지 테스트 하고 싶었는데, 부하테스트까지는 하지 못했다.   

또 연결만 하고 공부가 부족해서 대시보드에서 어떤 데이터를 체크해야하는지 알 수 없었다...!(내 예쁜 무쓸모 대시보드...!)
